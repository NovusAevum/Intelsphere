import jsPDF from 'jspdf';
import 'jspdf-autotable';

export interface ExportData {
  title: string;
  subtitle?: string;
  timestamp: string;
  data: any[];
  metadata?: {
    source: string;
    query: string;
    totalResults: number;
    exportedBy: string;
  };
}

export interface ExportOptions {
  format: 'pdf' | 'csv' | 'json';
  includeMetadata: boolean;
  customFields?: string[];
  filename?: string;
}

export class ExportEngine {
  async exportData(data: ExportData, options: ExportOptions): Promise<{ 
    content: string | Buffer;
    filename: string;
    mimeType: string;
  }> {
    const timestamp = new Date().toISOString().split('T')[0];
    const filename = options.filename || `${data.title.toLowerCase().replace(/\s+/g, '-')}-${timestamp}`;

    switch (options.format) {
      case 'pdf':
        return this.exportToPDF(data, options, filename);
      case 'csv':
        return this.exportToCSV(data, options, filename);
      case 'json':
        return this.exportToJSON(data, options, filename);
      default:
        throw new Error('Unsupported export format');
    }
  }

  private async exportToPDF(data: ExportData, options: ExportOptions, filename: string): Promise<{
    content: Buffer;
    filename: string;
    mimeType: string;
  }> {
    const doc = new jsPDF();
    
    // Header
    doc.setFontSize(20);
    doc.text(data.title, 20, 30);
    
    if (data.subtitle) {
      doc.setFontSize(14);
      doc.text(data.subtitle, 20, 45);
    }
    
    // Metadata section
    let yPosition = data.subtitle ? 60 : 45;
    
    if (options.includeMetadata && data.metadata) {
      doc.setFontSize(12);
      doc.text(`Generated: ${data.timestamp}`, 20, yPosition);
      yPosition += 10;
      
      if (data.metadata.source) {
        doc.text(`Source: ${data.metadata.source}`, 20, yPosition);
        yPosition += 10;
      }
      
      if (data.metadata.query) {
        doc.text(`Query: ${data.metadata.query}`, 20, yPosition);
        yPosition += 10;
      }
      
      if (data.metadata.totalResults) {
        doc.text(`Total Results: ${data.metadata.totalResults}`, 20, yPosition);
        yPosition += 10;
      }
      
      yPosition += 10;
    }

    // Data table
    if (data.data && data.data.length > 0) {
      const tableData = this.prepareTableData(data.data, options.customFields);
      
      (doc as any).autoTable({
        head: [tableData.headers],
        body: tableData.rows,
        startY: yPosition,
        styles: {
          fontSize: 8,
          cellPadding: 3,
        },
        headStyles: {
          fillColor: [71, 85, 105],
          textColor: 255,
          fontStyle: 'bold'
        },
        alternateRowStyles: {
          fillColor: [248, 250, 252]
        },
        margin: { top: 20, left: 20, right: 20 }
      });
    }

    // Footer
    const pageCount = (doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.text(`Page ${i} of ${pageCount}`, 20, doc.internal.pageSize.height - 10);
      doc.text(`Generated by NexusIntel 2.0v - ${new Date().toLocaleString()}`, 
        doc.internal.pageSize.width - 20, doc.internal.pageSize.height - 10, { align: 'right' });
    }

    const pdfBuffer = Buffer.from(doc.output('arraybuffer'));
    
    return {
      content: pdfBuffer,
      filename: `${filename}.pdf`,
      mimeType: 'application/pdf'
    };
  }

  private exportToCSV(data: ExportData, options: ExportOptions, filename: string): {
    content: string;
    filename: string;
    mimeType: string;
  } {
    let csvContent = '';
    
    // Header information
    if (options.includeMetadata) {
      csvContent += `# ${data.title}\n`;
      if (data.subtitle) csvContent += `# ${data.subtitle}\n`;
      csvContent += `# Generated: ${data.timestamp}\n`;
      
      if (data.metadata) {
        if (data.metadata.source) csvContent += `# Source: ${data.metadata.source}\n`;
        if (data.metadata.query) csvContent += `# Query: ${data.metadata.query}\n`;
        if (data.metadata.totalResults) csvContent += `# Total Results: ${data.metadata.totalResults}\n`;
      }
      csvContent += '#\n';
    }

    // Data
    if (data.data && data.data.length > 0) {
      const tableData = this.prepareTableData(data.data, options.customFields);
      
      // Headers
      csvContent += tableData.headers.join(',') + '\n';
      
      // Rows
      tableData.rows.forEach(row => {
        const escapedRow = row.map(cell => {
          const cellStr = String(cell || '');
          // Escape quotes and wrap in quotes if contains comma, quote, or newline
          if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
            return `"${cellStr.replace(/"/g, '""')}"`;
          }
          return cellStr;
        });
        csvContent += escapedRow.join(',') + '\n';
      });
    }

    return {
      content: csvContent,
      filename: `${filename}.csv`,
      mimeType: 'text/csv'
    };
  }

  private exportToJSON(data: ExportData, options: ExportOptions, filename: string): {
    content: string;
    filename: string;
    mimeType: string;
  } {
    const exportObject: any = {
      title: data.title,
      timestamp: data.timestamp,
      data: data.data
    };

    if (data.subtitle) {
      exportObject.subtitle = data.subtitle;
    }

    if (options.includeMetadata && data.metadata) {
      exportObject.metadata = data.metadata;
    }

    if (options.customFields && options.customFields.length > 0) {
      exportObject.customFields = options.customFields;
      exportObject.data = data.data.map(item => {
        const filteredItem: any = {};
        options.customFields!.forEach(field => {
          if (item.hasOwnProperty(field)) {
            filteredItem[field] = item[field];
          }
        });
        return filteredItem;
      });
    }

    exportObject.exportInfo = {
      format: 'json',
      generatedBy: 'NexusIntel 2.0v',
      generatedAt: new Date().toISOString(),
      totalRecords: data.data ? data.data.length : 0
    };

    return {
      content: JSON.stringify(exportObject, null, 2),
      filename: `${filename}.json`,
      mimeType: 'application/json'
    };
  }

  private prepareTableData(data: any[], customFields?: string[]): { headers: string[]; rows: any[][] } {
    if (!data || data.length === 0) {
      return { headers: [], rows: [] };
    }

    // Determine fields to include
    let fields: string[];
    if (customFields && customFields.length > 0) {
      fields = customFields;
    } else {
      // Get all unique keys from all objects
      const allKeys = new Set<string>();
      data.forEach(item => {
        if (typeof item === 'object' && item !== null) {
          Object.keys(item).forEach(key => allKeys.add(key));
        }
      });
      fields = Array.from(allKeys);
    }

    // Create headers
    const headers = fields.map(field => 
      field.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())
    );

    // Create rows
    const rows = data.map(item => {
      return fields.map(field => {
        if (typeof item === 'object' && item !== null) {
          const value = item[field];
          
          // Handle different data types
          if (value === null || value === undefined) {
            return '';
          } else if (typeof value === 'object') {
            return JSON.stringify(value);
          } else if (Array.isArray(value)) {
            return value.join('; ');
          } else {
            return String(value);
          }
        }
        return String(item);
      });
    });

    return { headers, rows };
  }

  // Method to get sample export data for testing
  generateSampleExportData(): ExportData {
    return {
      title: "OSINT Research Results",
      subtitle: "Comprehensive Intelligence Analysis",
      timestamp: new Date().toISOString(),
      data: [
        {
          target: "example.com",
          ipAddress: "192.168.1.1",
          location: "United States",
          organization: "Example Corp",
          technologies: ["React", "Node.js", "PostgreSQL"],
          riskLevel: "Low",
          lastUpdated: new Date().toISOString(),
          confidence: 0.95
        },
        {
          target: "test.org",
          ipAddress: "10.0.0.1",
          location: "Canada",
          organization: "Test Organization",
          technologies: ["WordPress", "PHP", "MySQL"],
          riskLevel: "Medium",
          lastUpdated: new Date().toISOString(),
          confidence: 0.87
        }
      ],
      metadata: {
        source: "NexusIntel 2.0v",
        query: "Domain Intelligence Scan",
        totalResults: 2,
        exportedBy: "Mr. Hanis"
      }
    };
  }
}

export const exportEngine = new ExportEngine();